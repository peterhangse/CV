<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kommunprotokollsbevakare - Peter Hang</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .code-container {
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
        }
        .code-header {
            background: var(--card);
            padding: 30px;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            margin-bottom: 20px;
            text-align: center;
        }
        .code-header h1 {
            color: var(--accent);
            margin-bottom: 15px;
        }
        .code-header p {
            color: var(--muted);
            line-height: 1.6;
            font-size: 1.1em;
        }
        .code-box {
            background: #1e1e1e;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        .code-toolbar {
            background: #2d2d2d;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #3d3d3d;
        }
        .code-filename {
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .copy-button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 6px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: opacity var(--transition);
        }
        .copy-button:hover {
            opacity: 0.9;
        }
        .code-content {
            padding: 20px;
            overflow-x: auto;
        }
        .code-content pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            color: #d4d4d4;
        }
        .back-button-container {
            text-align: center;
            margin-top: 30px;
        }
        .back-button {
            display: inline-block;
            background: var(--accent);
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: 600;
            transition: opacity var(--transition);
        }
        .back-button:hover {
            opacity: 0.9;
        }
        @media (max-width: 720px) {
            .code-container {
                padding: 10px;
            }
            .code-content {
                padding: 10px;
            }
            .code-content pre {
                font-size: 0.75em;
            }
        }
    </style>
</head>
<body>
    <div class="code-container">
        <div class="code-header">
            <h1>Kommunprotokollsbevakare</h1>
            <p>Karlshamn Monitor - Ett Streamlit-baserat √∂vervakningssystem som bevakar Karlshamns kommun f√∂r nya protokoll och dokument via DocumentWeb API.</p>
        </div>
        
        <div class="code-box">
            <div class="code-toolbar">
                <span class="code-filename">karlshamn_monitor.py</span>
                <button class="copy-button" onclick="copyCode()">üìã Kopiera kod</button>
            </div>
            <div class="code-content">
                <pre id="pythonCode">"""
Karlshamn Monitor - Streamlit GUI
√ñvervakar Karlshamns kommun f√∂r nya protokoll/dokument via DocumentWeb API
"""
import streamlit as st
import sqlite3
import time
from datetime import datetime
import threading
import os
import smtplib
from typing import Dict, List

import requests
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

from karlshamn_alerter import (
    COMMITTEES,
    fetch_protocols,
    init_db as cli_init_db,
    build_message,
)

DB_FILE = os.path.join(os.path.dirname(__file__), "..", "alerter.db")

# ============================================================================
# DATABASE FUNCTIONS
# ============================================================================
def init_db():
    """Initierar databasen med samma schema som CLI-alertern."""
    cli_init_db(DB_FILE)

def get_all_items():
    """H√§mtar alla sparade items fr√•n databasen"""
    con = sqlite3.connect(DB_FILE)
    try:
        cur = con.execute("""
            SELECT url, title, first_seen, committee
            FROM items 
            ORDER BY first_seen DESC
        """)
        items = []
        for row in cur.fetchall():
            items.append({
                'url': row[0],
                'title': row[1],
                'first_seen': datetime.fromtimestamp(row[2]).strftime('%Y-%m-%d %H:%M:%S'),
                'committee': row[3] if row[3] else 'Ok√§nd'
            })
        return items
    finally:
        con.close()

def already_seen(url):
    """Kollar om URL redan finns i databasen"""
    con = sqlite3.connect(DB_FILE)
    try:
        cur = con.execute("SELECT 1 FROM items WHERE url = ?", (url,))
        return cur.fetchone() is not None
    finally:
        con.close()

def mark_seen(url, title, committee):
    """Markerar URL som sedd"""
    con = sqlite3.connect(DB_FILE)
    try:
        con.execute(
            "INSERT OR IGNORE INTO items (url, title, first_seen, committee) VALUES (?,?,?,?)",
            (url, title, int(time.time()), committee)
        )
        con.commit()
    finally:
        con.close()

def clear_database():
    """T√∂mmer hela databasen"""
    con = sqlite3.connect(DB_FILE)
    try:
        con.execute("DELETE FROM items")
        con.commit()
    finally:
        con.close()

# ============================================================================
# API HELPERS
# ============================================================================
def check_for_new_items(keywords, selected_committees, include_existing=False):
    """H√§mtar dokument via DocumentWeb API och returnerar matchningar."""
    keyword_terms = [term.lower() for term in keywords if term]
    chosen_committees = selected_committees or [c["name"] for c in COMMITTEES]
    committee_lookup = {c["name"]: c for c in COMMITTEES}

    hits = []
    for committee_name in chosen_committees:
        committee = committee_lookup.get(committee_name)
        if not committee:
            continue
        try:
            documents = list(fetch_protocols(committee["api_url"]))
        except Exception as exc:
            st.error(f"API-fel f√∂r {committee_name}: {exc}")
            continue

        for doc in documents:
            title = doc.get("name", "Ok√§nt dokument")
            haystack = " ".join([
                title,
                (doc.get("responsible") or {}).get("name", ""),
            ]).lower()
            if keyword_terms and not any(term in haystack for term in keyword_terms):
                continue

            document_id = doc.get("id")
            url = f"{committee['page_url']}#{document_id}" if document_id else committee["page_url"]
            is_new = not already_seen(url)
            if is_new:
                mark_seen(url, title, committee_name)

            if include_existing or is_new:
                hits.append(
                    {
                        "url": url,
                        "title": title,
                        "committee": committee_name,
                        "created": doc.get("createDate", ""),
                        "responsible": (doc.get("responsible") or {}).get("name"),
                        "is_new": is_new,
                        "doc": doc,
                        "direct_url": doc.get("publicUrl") or doc.get("downloadUrl"),
                    }
                )

    return hits

def send_telegram(bot_token, chat_id, message):
    """Skickar meddelande via Telegram"""
    try:
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        data = {"chat_id": chat_id, "text": message}
        resp = requests.post(url, data=data, timeout=10)
        return resp.status_code == 200
    except Exception as e:
        st.error(f"Telegram-fel: {e}")
        return False

def send_email(smtp_host, smtp_port, smtp_user, smtp_pass, from_email, to_email, subject, body):
    """Skickar email via SMTP"""
    try:
        msg = MIMEMultipart()
        msg['From'] = from_email
        msg['To'] = to_email
        msg['Subject'] = subject
        msg.attach(MIMEText(body, 'plain', 'utf-8'))
        
        with smtplib.SMTP(smtp_host, smtp_port, timeout=10) as server:
            server.starttls()
            server.login(smtp_user, smtp_pass)
            server.send_message(msg)
        return True
    except Exception as e:
        st.error(f"Email-fel: {e}")
        return False

def notify_new_item(item, telegram_config, email_config):
    """Skickar notifikationer f√∂r nytt dokument."""
    committee = next((c for c in COMMITTEES if c["name"] == item["committee"]), None)
    if not committee:
        return []

    message = build_message(item["doc"], committee)
    if item.get("direct_url"):
        message += f"\nDirektl√§nk: {item['direct_url']}"

    results = []

    if telegram_config['enabled'] and telegram_config['token'] and telegram_config['chat_id']:
        success = send_telegram(telegram_config['token'], telegram_config['chat_id'], message)
        results.append(('Telegram', success))

    if email_config['enabled'] and all([
        email_config['smtp_host'],
        email_config['smtp_user'],
        email_config['to_email']
    ]):
        success = send_email(
            email_config['smtp_host'],
            email_config['smtp_port'],
            email_config['smtp_user'],
            email_config['smtp_pass'],
            email_config['from_email'],
            email_config['to_email'],
            f"üîî Karlshamn Monitor - {item['title']}",
            message
        )
        results.append(('Email', success))

    return results

# ============================================================================
# WATCH MODE FUNCTIONALITY
# ============================================================================
class WatchMonitor:
    """Hanterar watch-mode i bakgrunden"""

    def __init__(self):
        self.running = False
        self.thread = None
        self.last_check = None
        self.check_count = 0
        self.new_items_total = 0
        self.selected_committees = []
        self.keywords = []

    def start(self, keywords, committees, interval, telegram_config, email_config):
        if self.running:
            return False

        self.running = True
        self.selected_committees = committees
        self.keywords = keywords
        self.thread = threading.Thread(
            target=self._watch_loop,
            args=(interval, telegram_config, email_config),
            daemon=True
        )
        self.thread.start()
        return True

    def stop(self):
        self.running = False
        if self.thread:
            self.thread = None

    def _watch_loop(self, interval, telegram_config, email_config):
        while self.running:
            try:
                self.last_check = datetime.now()
                self.check_count += 1

                new_items = check_for_new_items(self.keywords, self.selected_committees, include_existing=False)

                for item in new_items:
                    if item['is_new']:
                        self.new_items_total += 1
                        notify_new_item(item, telegram_config, email_config)

            except Exception as e:
                print(f"Watch error: {e}")

            time.sleep(interval)

# Initialisera watch monitor i session state
if 'watch_monitor' not in st.session_state:
    st.session_state.watch_monitor = WatchMonitor()

# ============================================================================
# STREAMLIT UI
# ============================================================================
st.set_page_config(page_title="Karlshamn Monitor", page_icon="üîî", layout="wide")

st.title("üîî Karlshamn Monitor")
st.markdown("**√ñvervakar Karlshamns kommun f√∂r nya protokoll och dokument**")

# Initialisera databas
init_db()

# Sidebar - Konfiguration
with st.sidebar:
    st.header("‚öôÔ∏è Inst√§llningar")

    committee_names = [c["name"] for c in COMMITTEES]
    selected_committees = st.multiselect(
        "N√§mnder att √∂vervaka",
        committee_names,
        default=committee_names,
    )

    keywords_input = st.text_input(
        "Nyckelord (kommaseparerade)",
        value="",
        help="Filtrera p√• nyckelord, t.ex: 'protokoll, beslut, sammantr√§de'"
    )
    keywords = [k.strip() for k in keywords_input.split(",") if k.strip()]

    st.markdown("---")
    st.subheader("üìß Notifikationer")

    enable_telegram = st.checkbox("Aktivera Telegram", value=False)
    if enable_telegram:
        telegram_token = st.text_input("Bot Token", type="password", help="Telegram bot token fr√•n @BotFather")
        telegram_chat_id = st.text_input("Chat ID", help="Ditt Telegram chat ID")
    else:
        telegram_token = ""
        telegram_chat_id = ""

    enable_email = st.checkbox("Aktivera Email", value=False)
    if enable_email:
        smtp_host = st.text_input("SMTP Server", value="smtp.gmail.com", help="T.ex. smtp.gmail.com f√∂r Gmail")
        smtp_port = st.number_input("SMTP Port", value=587, min_value=1, max_value=65535)
        smtp_user = st.text_input("Email-adress (fr√•n)", help="Din email-adress")
        smtp_pass = st.text_input("Email-l√∂senord", type="password", help="App-specifikt l√∂senord f√∂r Gmail")
        to_email = st.text_input("Skicka till", help="Mottagarens email-adress")
    else:
        smtp_host = ""
        smtp_port = 587
        smtp_user = ""
        smtp_pass = ""
        to_email = ""

    st.markdown("---")
    st.subheader("üóëÔ∏è Databas")
    if st.button("Rensa databas", type="secondary"):
        clear_database()
        st.success("Databas rensad!")
        st.rerun()

# Huvudinneh√•ll - Tabs
tab1, tab2, tab3, tab4 = st.tabs(["üìä Manuell check", "üìú Historik", "ü§ñ Watch-mode", "‚öôÔ∏è 24/7 Setup"])

# ============================================================================
# TAB 1: MANUELL CHECK
# ============================================================================
with tab1:
    st.subheader("K√∂r manuell kontroll")
    
    col1, col2 = st.columns([3, 1])
    with col1:
        st.markdown("**API-k√§lla:** DocumentWeb")
        st.markdown(f"**N√§mnder:** {', '.join(selected_committees) if selected_committees else 'Alla'}")
        if keywords:
            st.markdown(f"**Filter:** {', '.join(keywords)}")
        else:
            st.markdown("**Filter:** Inga filter (visar alla dokument)")
    
    with col2:
        check_button = st.button("üîç Kolla nu", type="primary", use_container_width=True)
    
    if check_button:
        with st.spinner("H√§mtar protokoll fr√•n DocumentWeb..."):
            hits = check_for_new_items(keywords, selected_committees, include_existing=True)

        if hits:
            new_items = [item for item in hits if item['is_new']]
            seen_items = [item for item in hits if not item['is_new']]

            st.success(f"Hittade {len(hits)} dokument som matchar filtret")

            telegram_config = {
                'enabled': enable_telegram,
                'token': telegram_token,
                'chat_id': telegram_chat_id
            }
            email_config = {
                'enabled': enable_email,
                'smtp_host': smtp_host,
                'smtp_port': smtp_port,
                'smtp_user': smtp_user,
                'smtp_pass': smtp_pass,
                'from_email': smtp_user,
                'to_email': to_email
            }

            if new_items:
                st.markdown(f"### üÜï Nya dokument ({len(new_items)})")
                for item in new_items:
                    st.markdown(f"**{item['title']}**")
                    st.caption(item['committee'])
                    st.markdown(f"üîó [{item['url']}]({item['url']})")
                    if item.get('direct_url') and item['direct_url'] != item['url']:
                        st.markdown(f"üì• [Direktnedladdning]({item['direct_url']})")
                    if enable_telegram or enable_email:
                        results = notify_new_item(item, telegram_config, email_config)
                        if results:
                            notify_text = " | ".join([f"{service}: {'‚úÖ' if success else '‚ùå'}" for service, success in results])
                            st.caption(f"Notifikationer: {notify_text}")
                    st.markdown("---")

            if seen_items:
                with st.expander(f"Redan k√§nda dokument ({len(seen_items)})"):
                    for item in seen_items:
                        st.markdown(f"**{item['title']}**")
                        st.caption(item['committee'])
                        st.markdown(f"üîó [{item['url']}]({item['url']})")
                        if item.get('direct_url') and item['direct_url'] != item['url']:
                            st.markdown(f"üì• [Direktnedladdning]({item['direct_url']})")
                        st.markdown("---")
        else:
            st.warning("Inga dokument matchade filtret.")

# ============================================================================
# TAB 2: HISTORIK
# ============================================================================
with tab2:
    st.subheader("Historik √∂ver alla sparade items")
    
    items = get_all_items()
    if items:
        st.markdown(f"**Totalt antal protokoll:** {len(items)}")
        import pandas as pd
        df = pd.DataFrame(items)
        # Gruppera per n√§mnd
        for committee, group in df.groupby('committee'):
            st.subheader(f"üèõÔ∏è {committee} ({len(group)})")
            st.dataframe(
                group,
                use_container_width=True,
                column_config={
                    "url": st.column_config.LinkColumn("URL"),
                    "title": "Titel",
                    "first_seen": "F√∂rst sedd",
                    "committee": "N√§mnd"
                },
                hide_index=True
            )
    else:
        st.info("Ingen historik √§nnu. K√∂r en check f√∂rst!")

# ============================================================================
# TAB 3: WATCH MODE
# ============================================================================
with tab3:
    st.subheader("ü§ñ Automatisk √∂vervakning")
    
    # Warning om begr√§nsningar
    st.warning("""
    ‚ö†Ô∏è **OBS: Watch-mode i Streamlit har begr√§nsningar**
    
    Detta l√§ge kr√§ver att:
    - Streamlit-appen √§r √∂ppen i webbl√§saren
    - Browser-tabben inte st√§ngs
    - Datorn inte g√•r i vilol√§ge
    
    **F√∂r 24/7-√∂vervakning:** Anv√§nd ist√§llet **Tab 4: 24/7 Setup** d√§r du konfigurerar CLI-versionen med Windows Task Scheduler. Den k√∂rs helt i bakgrunden utan browser!
    """)
    
    st.markdown("---")
    
    # Konfigurera watch settings
    col1, col2 = st.columns(2)
    with col1:
        watch_interval = st.number_input(
            "Intervall (sekunder)",
            min_value=60,
            max_value=3600,
            value=600,
            step=60,
            help="Hur ofta ska sidan kollas? (minst 60 sekunder)"
        )
    
    with col2:
        st.metric("Status", "‚ñ∂Ô∏è K√∂rs" if st.session_state.watch_monitor.running else "‚è∏Ô∏è Stoppad")
    
    # Status information
    if st.session_state.watch_monitor.running:
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Antal k√∂rningar", st.session_state.watch_monitor.check_count)
        with col2:
            st.metric("Nya dokument", st.session_state.watch_monitor.new_items_total)
        with col3:
            if st.session_state.watch_monitor.last_check:
                last_check_str = st.session_state.watch_monitor.last_check.strftime('%H:%M:%S')
                st.metric("Senaste check", last_check_str)
        st.caption(
            "√ñvervakar: "
            + (
                ", ".join(st.session_state.watch_monitor.selected_committees)
                if st.session_state.watch_monitor.selected_committees
                else "Alla n√§mnder"
            )
        )
    
    st.markdown("---")
    
    # Start/Stop buttons
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("‚ñ∂Ô∏è Starta Watch-mode", type="primary", disabled=st.session_state.watch_monitor.running, use_container_width=True):
            # Skapa config f√∂r notifikationer
            telegram_config = {
                'enabled': enable_telegram,
                'token': telegram_token,
                'chat_id': telegram_chat_id
            }
            email_config = {
                'enabled': enable_email,
                'smtp_host': smtp_host,
                'smtp_port': int(smtp_port),
                'smtp_user': smtp_user,
                'smtp_pass': smtp_pass,
                'from_email': smtp_user,
                'to_email': to_email
            }
            
            success = st.session_state.watch_monitor.start(
                keywords,
                selected_committees,
                watch_interval,
                telegram_config,
                email_config
            )
            
            if success:
                st.success(f"‚úÖ Watch-mode startad! Kollar var {watch_interval}s.")
                st.rerun()
            else:
                st.error("‚ùå Kunde inte starta watch-mode")
    
    with col2:
        if st.button("‚èπÔ∏è Stoppa Watch-mode", type="secondary", disabled=not st.session_state.watch_monitor.running, use_container_width=True):
            st.session_state.watch_monitor.stop()
            st.info("‚è∏Ô∏è Watch-mode stoppad")
            st.rerun()
    
    st.markdown("---")
    st.markdown(
        """
    ### ‚ÑπÔ∏è Om Watch-mode

    **Hur det fungerar:**
    - üîÑ H√§mtar protokoll via DocumentWeb API med valt intervall
    - üîî Skickar notifikationer n√§r nya dokument hittas (Telegram/Email)
    - üíæ Sparar alla nya poster i databasen
    - üîí K√∂rs i bakgrunden som en separat tr√•d

    **Tips:**
    - Rekommenderat intervall: 10 minuter (600s) eller mer
    - Aktivera notifikationer i sidomenyn f√∂re start
    - Watch-mode forts√§tter k√∂ra √§ven om du byter tab
    - Stoppas automatiskt n√§r du st√§nger appen

    **Telegram setup:**
    1. Skapa bot via @BotFather p√• Telegram
    2. Kopiera bot token
    3. Starta en chat med din bot
    4. F√• ditt chat ID fr√•n @userinfobot

    **Gmail setup:**
    1. Anv√§nd `smtp.gmail.com` och port `587`
    2. Skapa ett "App-specifikt l√∂senord" i Google-kontot
    3. Anv√§nd det l√∂senordet h√§r (inte ditt vanliga l√∂senord)
    """
    )

    if st.session_state.watch_monitor.running and not (enable_telegram or enable_email):
        st.warning("‚ö†Ô∏è Watch-mode k√∂rs men inga notifikationer √§r aktiverade!")

# ============================================================================
# TAB 4: 24/7 SETUP (CLI + TASK SCHEDULER)
# ============================================================================
with tab4:
    st.subheader("‚öôÔ∏è Setup f√∂r 24/7-√∂vervakning")
    
    st.markdown("""
    ### üéØ Rekommenderad l√∂sning f√∂r 24/7-√∂vervakning
    
    **Watch-mode i Tab 3** fungerar men har begr√§nsningar:
    - ‚ö†Ô∏è Kr√§ver att Streamlit-appen √§r √∂ppen i webbl√§saren
    - ‚ö†Ô∏è Stoppas n√§r du st√§nger browser-tabben
    - ‚ö†Ô∏è L√∂senord m√•ste anges varje g√•ng
    
    **B√§ttre l√∂sning:** Anv√§nd CLI-versionen + Windows Task Scheduler
    - ‚úÖ K√∂rs helt i bakgrunden (ingen browser beh√∂vs)
    - ‚úÖ Startar automatiskt vid uppstart
    - ‚úÖ S√§kra credentials i `.env`-fil
    - ‚úÖ Samma databas som Streamlit (du ser historik h√§r)
    """)
    
    st.markdown("---")
    
    # .ENV EDITOR
    st.subheader("üìù Steg 1: Konfigurera .env-fil")
    
    env_file_path = os.path.join(os.path.dirname(__file__), "..", "karlshamn_alerter.py")
    env_dir = os.path.dirname(os.path.abspath(env_file_path))
    env_path = os.path.join(env_dir, ".env")
    
    st.markdown(f"**Plats:** `{env_path}`")
    
    # L√§s nuvarande .env om den finns
    current_env = {}
    if os.path.exists(env_path):
        try:
            with open(env_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        current_env[key.strip()] = value.strip()
        except Exception as e:
            st.error(f"Kunde inte l√§sa .env: {e}")
    
    with st.form("env_editor"):
        st.markdown("**Konfigurera inst√§llningar:**")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("##### üåê API-baserad √∂vervakning")
            st.info("""
            ‚ö° **Anv√§nder DocumentWeb API direkt**
            
            Ingen URL-konfiguration beh√∂vs l√§ngre! API-endpoint √§r h√•rdkodad.
            
            **Resultat:**
            - üéØ 7 protokoll (inte 710 slumpl√§nkar)
            - ‚ö° Mycket snabbare
            - üîí Mer p√•litlig
            """)
            
            st.markdown("##### üìß Email (SMTP)")
            env_smtp_host = st.text_input(
                "SMTP_HOST",
                value=current_env.get('SMTP_HOST', 'smtp.gmail.com'),
                help="SMTP-server"
            )
            env_smtp_port = st.text_input(
                "SMTP_PORT",
                value=current_env.get('SMTP_PORT', '587'),
                help="SMTP-port (587 f√∂r TLS)"
            )
            env_smtp_user = st.text_input(
                "SMTP_USER",
                value=current_env.get('SMTP_USER', ''),
                help="Din email-adress"
            )
            env_smtp_pass = st.text_input(
                "SMTP_PASS",
                value=current_env.get('SMTP_PASS', ''),
                type="password",
                help="App-specifikt l√∂senord (Gmail)"
            )
        
        with col2:
            env_from_email = st.text_input(
                "FROM_EMAIL",
                value=current_env.get('FROM_EMAIL', current_env.get('SMTP_USER', 'alerter@example.com')),
                help="Avs√§ndaradress (oftast samma som SMTP_USER)"
            )
            env_to_email = st.text_input(
                "TO_EMAIL",
                value=current_env.get('TO_EMAIL', ''),
                help="Mottagaradress (dit notifikationer skickas)"
            )
            
            st.markdown("##### üì± Telegram (valfritt)")
            env_telegram_token = st.text_input(
                "TELEGRAM_BOT_TOKEN",
                value=current_env.get('TELEGRAM_BOT_TOKEN', ''),
                type="password",
                help="Fr√•n @BotFather"
            )
            env_telegram_chat = st.text_input(
                "TELEGRAM_CHAT_ID",
                value=current_env.get('TELEGRAM_CHAT_ID', ''),
                help="Ditt chat ID (fr√•n @userinfobot)"
            )
        
        st.markdown("---")
        
        col1, col2 = st.columns([3, 1])
        with col1:
            st.caption("üíæ Detta sparar credentials s√§kert i `.env`-fil (ej i versionskontroll)")
        with col2:
            save_button = st.form_submit_button("üíæ Spara .env", type="primary", use_container_width=True)
    
    if save_button:
        try:
            env_content = f"""# Karlshamn Alerter Configuration (API Version)
# Genererad av Streamlit: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# 
# Anv√§nder DocumentWeb API direkt - ingen TARGET_URL beh√∂vs!
# API: https://documentweb.karlshamn.se/api/folders/7901f0b7-9088-472a-a8fe-7437084ad1c1

# Email (SMTP)
SMTP_HOST={env_smtp_host}
SMTP_PORT={env_smtp_port}
SMTP_USER={env_smtp_user}
SMTP_PASS={env_smtp_pass}
FROM_EMAIL={env_from_email}
TO_EMAIL={env_to_email}

# Telegram (optional)
TELEGRAM_BOT_TOKEN={env_telegram_token}
TELEGRAM_CHAT_ID={env_telegram_chat}
"""
            with open(env_path, 'w', encoding='utf-8') as f:
                f.write(env_content)
            
            st.success(f"‚úÖ .env-fil sparad: `{env_path}`")
        except Exception as e:
            st.error(f"‚ùå Kunde inte spara .env: {e}")
    
    st.markdown("---")
    
    # TASK SCHEDULER SETUP
    st.subheader("üïê Steg 2: Konfigurera Windows Task Scheduler")
    
    st.markdown("""
    **Automatisk k√∂rning var 10:e minut:**
    
    1. **√ñppna Task Scheduler:**
       - Tryck `Win + R`, skriv `taskschd.msc`, tryck Enter
    
    2. **Skapa ny task:**
       - H√∂gerklicka "Task Scheduler Library" ‚Üí "Create Basic Task"
       - Namn: `Karlshamn Monitor`
       - Beskrivning: `√ñvervakar Karlshamns kommun f√∂r nya dokument`
    
    3. **Trigger (n√§r):**
       - V√§lj "Daily"
       - Start: Idag kl 00:00
       - ‚úÖ Kryssa i "Repeat task every: 10 minutes"
       - Duration: "Indefinitely"
    
    4. **Action (vad):**
       - V√§lj "Start a program"
       - Kopiera kommandot nedan üëá
    """)
    
    # Generera kommando - ANV√ÑNDER API-VERSION (namnbytt till karlshamn_alerter.py)
    venv_python = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".venv", "Scripts", "python.exe"))
    script_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "karlshamn_alerter.py"))
    working_dir = os.path.dirname(script_path)
    
    st.markdown("**Program/script:**")
    st.code(venv_python, language="text")
    
    st.markdown("**Arguments:**")
    st.code(f'"{script_path}" --watch --interval 600', language="text")
    
    st.markdown("**Start in (arbetskatalog):**")
    st.code(working_dir, language="text")
    
    st.info("""
    üí° **Tips:**
    - `--watch` = K√∂r kontinuerligt
    - `--interval 600` = Kolla var 10:e minut (600 sekunder)
    - √Ñndra intervall efter behov (300 = 5 min, 1800 = 30 min)
    """)
    
    st.markdown("---")
    
    # TEST CLI
    st.subheader("üß™ Steg 3: Testa CLI-versionen")
    
    st.markdown("**K√∂r en test innan du s√§tter upp Task Scheduler:**")
    
    test_command = f'"{venv_python}" "{script_path}" --debug'
    
    st.code(test_command, language="powershell")
    
    col1, col2 = st.columns([3, 1])
    with col1:
        st.markdown("Detta k√∂r **en** kontroll och visar debug-information")
    with col2:
        if st.button("üìã Kopiera kommando", use_container_width=True):
            st.code(test_command, language="text")
            st.caption("‚Üë Kopiera och k√∂r i PowerShell")
    
    st.markdown("---")
    
    # VERIFY SETUP
    st.subheader("‚úÖ Steg 4: Verifiera att allt fungerar")
    
    st.markdown("""
    **Checklista:**
    
    1. ‚úÖ `.env`-fil skapad med alla inst√§llningar
    2. ‚úÖ CLI-test k√∂rs utan fel (`--debug`)
    3. ‚úÖ Email kommer fram (kolla skr√§ppost f√∂rsta g√•ngen)
    4. ‚úÖ Task Scheduler-task skapad
    5. ‚úÖ Task k√∂rs var 10:e minut
    6. ‚úÖ Historik syns i Tab 2 h√§r i Streamlit
    
    **Fels√∂kning:**
    - Inget email? ‚Üí Kolla Gmail app-l√∂senord, kolla skr√§ppost
    - Task k√∂rs inte? ‚Üí Kolla Task Scheduler History (h√∂gerpanel)
    - Telegram funkar inte? ‚Üí Kolla bot token och chat ID
    - Dubbletter? ‚Üí B√•da systemen anv√§nder samma databas, inga dubbletter!
    """)
    
    st.success("""
    üéâ **N√§r allt √§r uppsatt:**
    - CLI k√∂rs automatiskt i bakgrunden var 10:e minut
    - Du f√•r email n√§r nya dokument hittas
    - √ñppna Streamlit n√§r du vill se historik eller g√∂ra manuella kontroller
    - Inga dubbletter - samma databas anv√§nds √∂verallt!
    """)

# Footer
st.markdown("---")
st.markdown("üí° **Tips:** L√§gg till nyckelord f√∂r att filtrera resultat, t.ex: 'protokoll, beslut'")</pre>
            </div>
        </div>
        
        <div class="back-button-container">
            <a href="index.html" class="back-button">Tillbaka till CV</a>
        </div>
    </div>

    <script>
        /**
         * Copy code to clipboard
         * Uses modern Clipboard API (requires HTTPS in all browsers except localhost for security)
         * Falls back to deprecated execCommand for older browsers or non-HTTPS contexts
         */
        function copyCode() {
            const codeElement = document.getElementById('pythonCode');
            const text = codeElement.textContent;
            
            // Use modern Clipboard API if available (requires HTTPS except on localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    updateCopyButton(true);
                }).catch(err => {
                    console.error('Clipboard API failed:', err);
                    fallbackCopy(text);
                });
            } else {
                // Fallback for older browsers or non-HTTPS contexts
                fallbackCopy(text);
            }
        }
        
        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                updateCopyButton(successful);
                if (!successful) {
                    console.error('Copy command failed');
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                updateCopyButton(false);
            }
            document.body.removeChild(textArea);
        }
        
        function updateCopyButton(success) {
            const button = document.querySelector('.copy-button');
            const originalText = button.textContent;
            if (success) {
                button.textContent = '‚úÖ Kopierad!';
            } else {
                button.textContent = '‚ùå Misslyckades';
            }
            setTimeout(() => {
                button.textContent = originalText;
            }, 2000);
        }
    </script>
</body>
</html>
